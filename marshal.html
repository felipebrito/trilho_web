<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>Painel + TV ‚Äî 1080√ó1920</title>
  <!-- 
    CALIBRA√á√ÉO PADR√ÉO (bg300x200-comtv.jpg):
    - Escala: 36.1% (0.361)
    - Offset X: -1.12488px (posi√ß√£o inicial testada)
    - Offset Y: -542.793px (posi√ß√£o inicial testada)
    - Trilho: 0-15928px (17008-1080)
    - Dimens√µes: 17008√ó11339px (imagem real)
    
    Valores baseados na posi√ß√£o inicial que funciona:
    - Posi√ß√£o inicial: translate(-1.12488px, -542.793px) scale(0.361)
    - Imagem: bg300x200-comtv.jpg (17008√ó11339px)
  -->
  <style>
    :root{ --bg:#000; --text:#fff; --muted:#a9b4c2; --accent:#2dd19e; --frame:#333; }
    *{box-sizing:border-box; touch-action: none;}
    html,body{height:100%}
    body{
      margin:0;background:var(--bg);color:var(--text);
      font:14px/1.4 system-ui,Segoe UI,Roboto,Arial,sans-serif;
      display:flex;flex-direction:column;align-items:center;justify-content:flex-start;
      min-height:100vh;overflow:auto
    }

    /* TV FIXA 1080x1920 */
    #tv{position:relative;width:100%;height:1920px;border:4px solid var(--frame);overflow:hidden;background:#111;border-radius:12px;flex-shrink:0;touch-action:none}
    #img{position:absolute;top:0;left:0;transform-origin:top left;will-change:transform;width:auto;height:auto;max-width:none;max-height:none;image-rendering:auto}

    /* Grid (ex.: 10 cm por quadrado) */
    .grid{position:absolute;inset:0;pointer-events:none;background-size:var(--g) var(--g), var(--g) var(--g);background-position:0 0, 0 0;background-image:linear-gradient(to right, rgba(255,255,255,.12) 1px, transparent 1px),linear-gradient(to bottom, rgba(255,255,255,.12) 1px, transparent 1px);display:none}

    .info{position:absolute;left:10px;top:10px;padding:6px 10px;background:rgba(0,0,0,.55);border:1px solid #2a2a2a;border-radius:999px;font-size:12px;backdrop-filter:blur(6px);z-index:4}
    .opHUD{position:absolute;top:12px;right:12px;background:rgba(0,0,0,.6);border:1px solid #2a2a2a;color:#d7e7ff;border-radius:999px;padding:6px 10px;font-size:12px;backdrop-filter:blur(6px);z-index:5}
    .hidden{display:none!important}

    .controls{
      margin-top: 60px;
      margin-left: 20px;
      /* display:flex;
      flex-wrap:wrap;
      gap:10px; */
      width:100%;
      max-width:1080px;
      position: absolute;
      top: 0;
      left: 0
    }

    label{font-size:13px;display:block;margin-bottom:6px}
    input[type=range], input[type=number], input[type=checkbox]{width:100%}
    input[type=range]{accent-color:var(--accent)}
    input[type=number]{padding:8px;border-radius:8px;border:1px solid #2a2a2a;background:#0c0c0c;color:var(--text)}
    .inline{display:flex;align-items:center;gap:8px}
    .hint{font-size:12px;color:var(--muted)}
    .kbd{font-family:ui-monospace,Menlo,Consolas,monospace;background:#0b0b0b;border:1px solid #2a2a2a;padding:1px 6px;border-radius:6px}
    button{padding:8px 10px;border-radius:8px;border:1px solid #2a2a2a;background:#0c0c0c;color:var(--text);cursor:pointer}
    .btns{display:flex;gap:8px}

    /* Bot√£o flutuante para mobile */
    .fab-toggle {
      position: fixed;
      right: 12px;
      top: 12px;
      z-index: 50;
      padding: 10px 14px;
      background: rgba(0,0,0,.6);
      border: 1px solid #2a2a2a;
      border-radius: 999px;
      color: #fff;
      font-size: 14px;
      line-height: 1;
      -webkit-tap-highlight-color: transparent;
      backdrop-filter: blur(6px);
    }
    .fab-toggle:active { transform: scale(0.98); }
    @media (min-width: 1100px) {
      .fab-toggle { right: 24px; top: 24px; }
    }
  </style>
</head>
<body>
  <div id="tv">
    <div id="opHUD" class="opHUD hidden">
      ‚Ä¢ pos <span id="opPos">0</span>% ‚Äî ‚Ä¢ tecla <b>C</b> para mostrar Controles ‚Äî ‚Ä¢ <b>Alt+Setas</b> para mover offsets
    </div>
    <img id="img" alt="arte" />
    <div id="grid" class="grid"></div>
    <div id="info" class="info">1080√ó1920 ‚Ä¢ escala 100% ‚Ä¢ pos 0% ‚Ä¢ off 0 / 0</div>
  </div>

  <button id="mobileToggle" class="fab-toggle mt-10" aria-label="Mostrar/ocultar controles">
    ‚ò∞ Controles
  </button>

  <div class="controls" id="controls">

    <div class="flex flex-col">
      <label>Carregar imagem
        <input id="file" type="file" accept="image/*" />
      </label>
      
      <!-- <div class="mt-4 flex w-40 items-center mb-4">
        <input id="fs" type="checkbox" value="" class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded-sm focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
        <label for="fs" class="ms-2 w-full text-sm font-medium text-gray-900 dark:text-gray-300">Tela cheia</label>
      </div>

      <div class="btns">
        <button class="bg-white text-black px-4 py-2" id="save">Salvar preset</button>
        <button class="bg-white text-black px-4 py-2" id="clear">Limpar preset</button>
        <button class="bg-white text-black px-4 py-2" id="toggleMode"><span id="modeLabel">Controles</span> (C)</button>
      </div> -->
    </div>

    <div class="mt-6 flex flex-col space-y-4">
      <label>Escala (%): <span id="sval">100</span>
        <input id="scale" type="range" min="5" max="400" step="0.1" value="100" />
      </label>
      <label>Posi√ß√£o no trilho (%): <span id="pval">0</span>
        <input id="pos" type="range" min="0" max="100" step="0.1" value="0" />
      </label>
      <label>Offset X (px): <span id="oxv">0</span>
        <input id="offX" type="range" min="-8000" max="8000" step="1" value="0" />
      </label>
      <label>Offset Y (px): <span id="oyv">0</span>
        <input id="offY" type="range" min="-8000" max="8000" step="1" value="0" />
      </label>
    </div>

    <div class="mt-6">

      <div class="btns">
        <button class="bg-white text-black px-4 py-2" id="save">Salvar preset</button>
        <button class="bg-white text-black px-4 py-2" id="clear">Limpar preset</button>
        <button class="bg-green-500 text-white px-4 py-2" id="reset">Reset Padr√£o</button>
        <button class="bg-blue-500 text-white px-4 py-2" id="findLimits">Encontrar Limites</button>
        <button class="bg-purple-500 text-white px-4 py-2" id="autoAdjust">Auto-Ajuste</button>
        <button class="bg-white text-black px-4 py-2" id="toggleMode"><span id="modeLabel">Controles</span> (C)</button>
      </div>
    </div>

    <div class="mt-6 flex w-40 items-center mb-4">
      <input id="fs" type="checkbox" value="" class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded-sm focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
      <label for="fs" class="ms-2 w-full text-sm font-medium text-gray-900 dark:text-gray-300">Tela cheia</label>
    </div>

    <div class="mt-6 flex w-40 items-center mb-4">
      <input id="toggleGrid" type="checkbox" value="" class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded-sm focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
      <label for="toggleGrid" class="ms-2 w-full text-sm font-medium text-gray-900 dark:text-gray-300">Grid</label>
    </div>

    <div class="mt-6 flex w-40 items-center mb-4">
      <label>Tamanho do quadrado (px) ‚Äî p/ 10 cm
        <input id="gridPx" type="number" min="10" max="800" value="100" />
      </label>
    </div>

  </div>

  <script>
    const $ = id => document.getElementById(id);
    const tv = $('tv');
    const img = $('img');

    const file = $('file');
    const fs = $('fs');

    const scale = $('scale');
    const pos = $('pos');
    const offX = $('offX');
    const offY = $('offY');

    const sval = $('sval');
    const pval = $('pval');
    const oxv = $('oxv');
    const oyv = $('oyv');

    const grid = $('grid');
    const toggleGrid = $('toggleGrid');
    const gridPx = $('gridPx');

    const info = $('info');

    const controls = $('controls');
    const opHUD = $('opHUD');
    const opPos = $('opPos');
    const toggleModeBtn = $('toggleMode');
    const modeLabel = $('modeLabel');

    const saveBtn = $('save');
    const clearBtn = $('clear');
    const resetBtn = $('reset');
    const findLimitsBtn = $('findLimits');
    const autoAdjustBtn = $('autoAdjust');

    const LSKEY = 'tv_cal_preset_v1';
    const MODEKEY = 'tv_mode_v1';

    const mobileToggle = $('mobileToggle');

    // Valores de calibra√ß√£o padr√£o (baseados na imagem real bg300x200-comtv.jpg)
    const DEFAULT_CALIBRATION = {
      scale: 0.361,
      offX: -1.12488,    // Posi√ß√£o inicial que funciona
      offY: -542.793,    // Posi√ß√£o inicial que funciona
      pos: 0,
      imgW: 17008,       // Largura real da imagem bg300x200-comtv.jpg
      imgH: 11339,       // Altura real da imagem bg300x200-comtv.jpg
      railLeftX: 0,
      railRightX: 15928, // 17008 - 1080 (largura da viewport)
      gridPx: 100,
      showGrid: false,
      mode: 'cal'
    };

    let S = { ...DEFAULT_CALIBRATION };

    function saveLocal(){ localStorage.setItem(LSKEY, JSON.stringify(S)); localStorage.setItem(MODEKEY, S.mode); }
    function loadLocal(){
      const s = localStorage.getItem(LSKEY); if(s){ try{ S = {...S, ...JSON.parse(s)} }catch(e){} }
      const m = localStorage.getItem(MODEKEY); if(m){ S.mode = m; }
    }
    
    function resetToDefault(){
      S = { ...DEFAULT_CALIBRATION };
      updateUI();
      render();
      console.log('üîÑ Reset para valores padr√£o de calibra√ß√£o');
    }
    
    function updateUI(){
      scale.value = (S.scale*100).toFixed(1);
      pos.value = S.pos.toFixed(1);
      offX.value = S.offX;
      offY.value = S.offY;
      gridPx.value = S.gridPx;
      toggleGrid.checked = S.showGrid;
    }
    
    function findLimits(){
      console.log('üîç Procurando limites do trilho...');
      
      // Testar diferentes posi√ß√µes para encontrar os limites
      const testPositions = [0, 25, 50, 75, 90, 95, 98, 99, 99.5, 99.9, 100];
      let currentIndex = 0;
      
      function testNextPosition(){
        if(currentIndex >= testPositions.length){
          console.log('‚úÖ Teste de limites conclu√≠do');
          return;
        }
        
        const testPos = testPositions[currentIndex];
        S.pos = testPos;
        pos.value = testPos;
        render();
        
        console.log(`üìç Testando posi√ß√£o ${testPos}% - translateX: ${((-S.pos/100 * (S.railRightX - S.railLeftX)) + S.offX).toFixed(2)}px`);
        
        currentIndex++;
        setTimeout(testNextPosition, 1000); // 1 segundo entre testes
      }
      
      testNextPosition();
    }
    
    function autoAdjust(){
      console.log('üéØ Iniciando auto-ajuste baseado no ret√¢ngulo vermelho...');
      
      // Par√¢metros para auto-ajuste
      const viewportWidth = 1080;
      const viewportHeight = 1920;
      const targetScale = 0.361; // Escala conhecida que funciona
      
      // Reset para posi√ß√£o inicial conhecida
      S.scale = targetScale;
      S.offX = -1.12488;
      S.offY = -542.793;
      S.pos = 0;
      
      // Atualizar UI
      updateUI();
      render();
      
      console.log('üìç Posi√ß√£o inicial configurada:');
      console.log(`   - Escala: ${(S.scale*100).toFixed(1)}%`);
      console.log(`   - Offset X: ${S.offX}px`);
      console.log(`   - Offset Y: ${S.offY}px`);
      console.log(`   - Posi√ß√£o: ${S.pos}%`);
      
      // Calcular limites baseados na imagem real
      const imageWidth = S.imgW;
      const imageHeight = S.imgH;
      const maxMovement = imageWidth - viewportWidth;
      
      // Ajustar railRightX baseado no movimento real
      S.railRightX = maxMovement;
      
      console.log('üìè Limites calculados:');
      console.log(`   - Imagem: ${imageWidth}√ó${imageHeight}px`);
      console.log(`   - Trilho: ${S.railLeftX} - ${S.railRightX}px`);
      console.log(`   - Movimento m√°ximo: ${maxMovement}px`);
      
      // Testar posi√ß√£o final (100%)
      S.pos = 100;
      pos.value = 100;
      render();
      
      const finalTranslateX = (-S.pos/100 * (S.railRightX - S.railLeftX)) + S.offX;
      console.log(`üìç Posi√ß√£o final (100%): translateX ${finalTranslateX.toFixed(2)}px`);
      
      // Voltar para posi√ß√£o inicial
      S.pos = 0;
      pos.value = 0;
      render();
      
      console.log('‚úÖ Auto-ajuste conclu√≠do! Use as setas para testar o movimento.');
    }
    
    function smartAutoAdjust(){
      console.log('üß† Iniciando auto-ajuste inteligente...');
      
      // Par√¢metros conhecidos que funcionam
      const workingParams = {
        scale: 0.361,
        offX: -1.12488,
        offY: -542.793,
        pos: 0
      };
      
      // Aplicar par√¢metros conhecidos
      S.scale = workingParams.scale;
      S.offX = workingParams.offX;
      S.offY = workingParams.offY;
      S.pos = workingParams.pos;
      
      // Calcular trilho baseado na imagem real
      const imageWidth = S.imgW;
      const imageHeight = S.imgH;
      const viewportWidth = 1080;
      
      // O ret√¢ngulo vermelho deve se encaixar perfeitamente na viewport
      // Isso significa que o movimento m√°ximo √© a largura da imagem menos a viewport
      S.railLeftX = 0;
      S.railRightX = imageWidth - viewportWidth;
      
      // Atualizar UI
      updateUI();
      render();
      
      console.log('üéØ Par√¢metros aplicados:');
      console.log(`   - Escala: ${(S.scale*100).toFixed(1)}%`);
      console.log(`   - Offset X: ${S.offX}px`);
      console.log(`   - Offset Y: ${S.offY}px`);
      console.log(`   - Trilho: ${S.railLeftX} - ${S.railRightX}px`);
      console.log(`   - Movimento: ${S.railRightX - S.railLeftX}px`);
      
      // Testar movimento completo
      console.log('üîÑ Testando movimento completo...');
      
      // Posi√ß√£o inicial (ret√¢ngulo vermelho alinhado)
      S.pos = 0;
      pos.value = 0;
      render();
      console.log(`üìç Posi√ß√£o 0%: translateX ${((-S.pos/100 * (S.railRightX - S.railLeftX)) + S.offX).toFixed(2)}px`);
      
      // Posi√ß√£o final (lado direito da imagem alinhado)
      S.pos = 100;
      pos.value = 100;
      render();
      console.log(`üìç Posi√ß√£o 100%: translateX ${((-S.pos/100 * (S.railRightX - S.railLeftX)) + S.offX).toFixed(2)}px`);
      
      // Voltar para in√≠cio
      S.pos = 0;
      pos.value = 0;
      render();
      
      console.log('‚úÖ Auto-ajuste inteligente conclu√≠do!');
      console.log('üéÆ Controles dispon√≠veis:');
      console.log('   - Setas: mover posi√ß√£o no trilho');
      console.log('   - Alt+Setas: mover offsets (calibra√ß√£o fina)');
      console.log('   - C: alternar modo calibra√ß√£o/opera√ß√£o');
    }

    function mapPosToImgX(){
      const t = S.pos / 100;
      return S.railLeftX + (S.railRightX - S.railLeftX) * t;
    }

    function setMode(m){
      S.mode = m;
      render();
    }

    function render(){
      sval.textContent = (S.scale*100).toFixed(1);
      pval.textContent = S.pos.toFixed(1);
      oxv.textContent = S.offX;
      oyv.textContent = S.offY;

      const imgX = mapPosToImgX();
      const tx = (-imgX + S.offX) * S.scale;
      const ty = (S.offY) * S.scale;
      img.style.transform = `translate(${tx}px, ${ty}px) scale(${S.scale})`;

      grid.style.setProperty('--g', S.gridPx + 'px');
      grid.style.display = S.showGrid ? 'block' : 'none';

      info.textContent = `1080√ó1920 ‚Ä¢ escala ${(S.scale*100).toFixed(1)}% ‚Ä¢ pos ${S.pos.toFixed(1)}% ‚Ä¢ off ${S.offX.toFixed(1)} / ${S.offY.toFixed(1)} ‚Ä¢ trilho ${S.railLeftX}-${S.railRightX}`;
      opPos.textContent = S.pos.toFixed(1);

      mobileToggle.textContent = (S.mode === 'op') ? '‚ò∞ Controles' : '‚úï Ocultar';

      // UI por modo
      if(S.mode === 'op'){
        controls.classList.add('hidden');
        info.classList.add('hidden');
        opHUD.classList.remove('hidden');
        modeLabel.textContent = 'Opera√ß√£o';
      } else {
        controls.classList.remove('hidden');
        info.classList.remove('hidden');
        opHUD.classList.add('hidden');
        modeLabel.textContent = 'Controles';
      }

      saveLocal();
    }

    file.addEventListener('change', e => {
      const f = e.target.files?.[0]; if(!f) return;
      const url = URL.createObjectURL(f);
      img.onload = () => {
        S.imgW = img.naturalWidth; S.imgH = img.naturalHeight;
        S.railLeftX = 0;
        S.railRightX = Math.max(0, S.imgW - 1080); // viewport √© 1080 de largura
        render();
      };
      img.src = url;
    });

    scale.addEventListener('input', ()=>{ S.scale = parseFloat(scale.value)/100; render(); });
    pos.addEventListener('input', ()=>{ S.pos = parseFloat(pos.value); render(); });
    offX.addEventListener('input', ()=>{ S.offX = parseInt(offX.value,10); render(); });
    offY.addEventListener('input', ()=>{ S.offY = parseInt(offY.value,10); render(); });

    toggleGrid.addEventListener('change', ()=>{ S.showGrid = toggleGrid.checked; render(); });
    gridPx.addEventListener('input', ()=>{ S.gridPx = Math.max(2, parseInt(gridPx.value||'100',10)); render(); });

    saveBtn.addEventListener('click', saveLocal);
    clearBtn.addEventListener('click', ()=>{ localStorage.removeItem(LSKEY); alert('Preset limpo.'); });
    resetBtn.addEventListener('click', resetToDefault);
    findLimitsBtn.addEventListener('click', findLimits);
    autoAdjustBtn.addEventListener('click', smartAutoAdjust);

    // Fullscreen opcional
    fs.addEventListener('change', async ()=>{
      if(fs.checked){ try{ await (document.body.requestFullscreen?.() || document.documentElement.requestFullscreen?.()); }catch(e){} }
      else { document.exitFullscreen?.(); }
    });

    // ======== TOUCH ========
    let lastTouch = null;   // {x,y}
    let pinch = null;       // {d0, s0, cx, cy}

    function tvPointFromTouch(t){ const r = tv.getBoundingClientRect(); return { x: t.clientX - r.left, y: t.clientY - r.top }; }
    function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

    tv.addEventListener('touchstart', (e)=>{
      if(S.mode === 'op'){
        if(e.touches.length===1){ lastTouch = tvPointFromTouch(e.touches[0]); }
        return;
      }
      if(e.touches.length===1){
        lastTouch = tvPointFromTouch(e.touches[0]);
      } else if(e.touches.length===2){
        const p1 = tvPointFromTouch(e.touches[0]);
        const p2 = tvPointFromTouch(e.touches[1]);
        const d0 = dist(p1,p2);
        const cx = (p1.x+p2.x)/2; const cy = (p1.y+p2.y)/2;
        pinch = { d0, s0: S.scale, cx, cy };
      }
    }, {passive:false});

    tv.addEventListener('touchmove', (e)=>{
      e.preventDefault();
      if(S.mode === 'op'){
        if(e.touches.length===1 && lastTouch){
          const p = tvPointFromTouch(e.touches[0]);
          const dx = p.x - lastTouch.x;            // arrasto horizontal
          const step = dx / 5;                      // sensibilidade
          S.pos = Math.max(0, Math.min(100, S.pos + step));
          pos.value = S.pos; lastTouch = p; render();
        }
        return;
      }
      if(e.touches.length===1 && lastTouch){
        const p = tvPointFromTouch(e.touches[0]);
        const dx = p.x - lastTouch.x; const dy = p.y - lastTouch.y;
        S.offX += Math.round(dx / S.scale);
        S.offY += Math.round(dy / S.scale);
        offX.value = S.offX; offY.value = S.offY;
        lastTouch = p; render();
      }
      if(e.touches.length===2 && pinch){
        const p1 = tvPointFromTouch(e.touches[0]);
        const p2 = tvPointFromTouch(e.touches[1]);
        const d1 = dist(p1,p2);
        let newScale = pinch.s0 * (d1 / pinch.d0);
        newScale = Math.min(4.0, Math.max(0.05, newScale));
        const s = S.scale, s2 = newScale; const cx = pinch.cx, cy = pinch.cy;
        S.offX = Math.round(S.offX + cx*(1/s2 - 1/s));
        S.offY = Math.round(S.offY + cy*(1/s2 - 1/s));
        S.scale = newScale; scale.value = (S.scale*100).toFixed(1);
        render();
      }
    }, {passive:false});

    tv.addEventListener('touchend', (e)=>{
      if(e.touches.length===0){ lastTouch=null; pinch=null; }
      if(e.touches.length===1){ pinch=null; lastTouch = tvPointFromTouch(e.touches[0]); }
    });

    // Teclado
    window.addEventListener('keydown', (e)=>{
      if(e.key.toLowerCase()==='c'){ setMode(S.mode==='cal'?'op':'cal'); return; }
      const step = e.shiftKey ? 10 : 1;
      if(S.mode==='cal' && e.altKey){
        if(e.key==='ArrowLeft'){ S.offX -= step; offX.value = S.offX; render(); }
        if(e.key==='ArrowRight'){ S.offX += step; offX.value = S.offX; render(); }
        if(e.key==='ArrowUp'){ S.offY -= step; offY.value = S.offY; render(); }
        if(e.key==='ArrowDown'){ S.offY += step; offY.value = S.offY; render(); }
      }
      if(e.key==='ArrowLeft' && !e.altKey){ S.pos = Math.max(0, S.pos - (e.shiftKey?5:1)); pos.value = S.pos; render(); }
      if(e.key==='ArrowRight' && !e.altKey){ S.pos = Math.min(100, S.pos + (e.shiftKey?5:1)); pos.value = S.pos; render(); }
    });

    // Fun√ß√£o para carregar imagem padr√£o (bg300x200-comtv.jpg)
    function loadDefaultImage(){
      if(!img.src || img.src === ''){
        // Tentar carregar a imagem real primeiro
        img.src = 'editor/bg300x200-comtv.jpg';
        img.onload = () => {
          S.imgW = img.naturalWidth;
          S.imgH = img.naturalHeight;
          S.railLeftX = 0;
          S.railRightX = Math.max(0, S.imgW - 1080);
          console.log(`üñºÔ∏è Imagem carregada: ${S.imgW}√ó${S.imgH}px`);
          render();
        };
        img.onerror = () => {
          // Fallback: criar imagem padr√£o se a real n√£o carregar
          console.log('‚ö†Ô∏è Imagem real n√£o encontrada, criando fallback');
          const canvas = document.createElement('canvas');
          canvas.width = S.imgW;
          canvas.height = S.imgH;
          const ctx = canvas.getContext('2d');
          
          // Gradiente de fundo para visualiza√ß√£o
          const gradient = ctx.createLinearGradient(0, 0, S.imgW, 0);
          gradient.addColorStop(0, '#1a1a2e');
          gradient.addColorStop(0.5, '#16213e');
          gradient.addColorStop(1, '#0f3460');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, S.imgW, S.imgH);
          
          // Adicionar texto de refer√™ncia
          ctx.fillStyle = '#ffffff';
          ctx.font = '48px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('TRILHO DIGITAL', S.imgW/2, S.imgH/2 - 50);
          ctx.font = '24px Arial';
          ctx.fillText(`${S.imgW}√ó${S.imgH}px`, S.imgW/2, S.imgH/2 + 20);
          ctx.fillText('Calibra√ß√£o Padr√£o', S.imgW/2, S.imgH/2 + 50);
          
          img.src = canvas.toDataURL();
          img.onload = () => {
            S.railLeftX = 0;
            S.railRightX = Math.max(0, S.imgW - 1080);
            render();
          };
        };
      }
    }

    // Boot
    loadLocal();
    const urlMode = new URLSearchParams(location.search).get('mode');
    if(urlMode==='op'){ S.mode='op'; }
    updateUI();
    loadDefaultImage();
    render();
    toggleModeBtn.addEventListener('click', ()=> setMode(S.mode==='cal'?'op':'cal'));
    mobileToggle.addEventListener('click', ()=> setMode(S.mode==='cal' ? 'op' : 'cal'));
  </script>
   <script src="https://cdn.tailwindcss.com"></script>
</body>
</html>