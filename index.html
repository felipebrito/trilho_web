<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trilho Digital</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #000;
            height: 100vh;
            overflow: hidden;
        }
        
        .viewport {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: #000;
            overflow: hidden;
        }
        
        .background-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            transform-origin: center center;
        }
        
        .slider {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 40px;
            background: rgba(0,0,0,0.7);
            border-radius: 20px;
            padding: 5px;
            z-index: 100;
        }
        
        .slider input {
            width: 100%;
            height: 100%;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            outline: none;
        }
        
        .slider input::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 30px;
            height: 30px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .position-display {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 18px;
            z-index: 100;
        }
        
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 25px;
            border-radius: 10px;
            z-index: 100;
            min-width: 300px;
            font-size: 16px;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 10px;
            font-size: 16px;
            font-weight: bold;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            height: 75px;
            margin-bottom: 5px;
            -webkit-appearance: none;
            appearance: none;
            background: #333;
            border-radius: 10px;
            outline: none;
        }
        
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 30px;
            height: 30px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .control-group input[type="range"]::-moz-range-thumb {
            width: 30px;
            height: 30px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .control-group input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 2px solid #555;
            background: #222;
            color: white;
            border-radius: 5px;
            font-size: 16px;
            margin-bottom: 10px;
        }
        
        .control-group input[type="number"]:focus {
            border-color: #4CAF50;
            outline: none;
        }
        
        .btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
            font-weight: bold;
        }

        /* √Årea de Intera√ß√£o Espec√≠fica */
        .interaction-area {
            position: absolute;
            width: 400px;
            height: 400px;
            background: rgba(255, 0, 0, 0.3);
            border: 3px solid #ff0000;
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            transform-origin: center center;
            /* Posi√ß√£o inicial: 100cm, 220cm (convertido para pixels) */
            left: 100px; /* 100cm = 100px para teste */
            top: 220px;  /* 220cm = 220px para teste */
        }

        .interaction-icon {
            font-size: 80px;
            animation: blink 1s infinite;
            margin-bottom: 20px;
        }

        .interaction-text {
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }
    </style>
</head>
<body>
    <div class="viewport">
        <div class="background-image" id="backgroundImage"></div>
        
        <!-- √Årea de Intera√ß√£o Espec√≠fica -->
        <div class="interaction-area" id="interactionArea" onclick="interactWithArea()">
            <div class="interaction-icon">üéØ</div>
            <div class="interaction-text">√Årea de Teste</div>
        </div>
                        </div>
                        
    <div class="controls">
                        <div class="control-group">
            <label>Escala: <span id="scaleValue">5.72</span></label>
            <input type="range" id="scaleSlider" min="0.1" max="10.0" step="0.01" value="5.72">
            <input type="number" id="scaleInput" min="0.1" max="10.0" step="0.01" value="5.72">
                        </div>
                        
                        <div class="control-group">
            <label>X: <span id="offsetXValue">446</span></label>
            <input type="range" id="offsetXSlider" min="-5000" max="5000" step="1" value="446">
            <input type="number" id="offsetXInput" min="-5000" max="5000" step="1" value="446">
                        </div>
                        
                        <div class="control-group">
            <label>Y: <span id="offsetYValue">96</span></label>
            <input type="range" id="offsetYSlider" min="-5000" max="5000" step="1" value="96">
            <input type="number" id="offsetYInput" min="-5000" max="5000" step="1" value="96">
        </div>
        
        <button class="btn" onclick="reset()">Reset</button>
        <button class="btn" onclick="center()">Centralizar</button>
        <button class="btn" onclick="fitToTV()">Encaixar na TV</button>
        <button class="btn" onclick="zoomIn()">+</button>
        <button class="btn" onclick="zoomOut()">-</button>
        <button class="btn" onclick="saveCalibration()">üíæ Salvar</button>
        <button class="btn" onclick="toggleMode()">üéÆ Modo Uso</button>
        <button class="btn" onclick="toggleUDP()" id="udpButton">üì° UDP OFF</button>
            </div>
            
    <div class="slider">
        <input type="range" id="positionSlider" min="0" max="100" step="0.1" value="0">
    </div>
    
    <div class="position-display" id="positionDisplay">0%</div>

    <!-- Cliente UDP -->
    <script src="udp-client.js"></script>
    
    <script>
        // Estado com valores que funcionaram - carregar j√° no tamanho correto
        let config = {
            scale: 5.72,
            offsetX: 446,
            offsetY: 96,
            position: 0
        };

        // Controle UDP
        let udpEnabled = false;
        let udpInterval = null;

        // √Årea de Intera√ß√£o Espec√≠fica
        const interactionArea = document.getElementById('interactionArea');

        // Configura√ß√£o do trilho
        const TRACK_LENGTH_CM = 300; // Comprimento total do trilho
        const TV_WIDTH_CM = 53.5; // Largura da TV
        const USABLE_TRACK_CM = TRACK_LENGTH_CM - TV_WIDTH_CM; // Trilho √∫til (246.5cm)

        // Elementos
        const backgroundImage = document.getElementById('backgroundImage');
        const positionSlider = document.getElementById('positionSlider');
        const positionDisplay = document.getElementById('positionDisplay');
        
        const scaleSlider = document.getElementById('scaleSlider');
        const scaleInput = document.getElementById('scaleInput');
        const scaleValue = document.getElementById('scaleValue');
        
        const offsetXSlider = document.getElementById('offsetXSlider');
        const offsetXInput = document.getElementById('offsetXInput');
        const offsetXValue = document.getElementById('offsetXValue');
        
        const offsetYSlider = document.getElementById('offsetYSlider');
        const offsetYInput = document.getElementById('offsetYInput');
        const offsetYValue = document.getElementById('offsetYValue');

        // Inicializar
        function init() {
            console.log('üöÄ Iniciando...');
            
            // Carregar imagem
            backgroundImage.style.backgroundImage = 'url(editor/bg300x200-comtv.jpg)';
            
            // Event listeners
            positionSlider.addEventListener('input', () => updatePosition(positionSlider.value));
            
            scaleSlider.addEventListener('input', () => updateScale(scaleSlider.value));
            scaleInput.addEventListener('input', () => updateScale(scaleInput.value));
            scaleInput.addEventListener('wheel', handleScroll);
            
            offsetXSlider.addEventListener('input', () => updateOffsetX(offsetXSlider.value));
            offsetXInput.addEventListener('input', () => updateOffsetX(offsetXInput.value));
            offsetXInput.addEventListener('wheel', handleScroll);
            
            offsetYSlider.addEventListener('input', () => updateOffsetY(offsetYSlider.value));
            offsetYInput.addEventListener('input', () => updateOffsetY(offsetYInput.value));
            offsetYInput.addEventListener('wheel', handleScroll);
            
            // Aplicar valores corretos automaticamente (sem carregar calibra√ß√£o antiga)
            applyCorrectValues();
            
            console.log('‚úÖ Pronto!');
        }
        
        // Aplicar valores corretos automaticamente
        function applyCorrectValues() {
            config.scale = 5.72;
            config.offsetX = 446;
            config.offsetY = 96;
            config.position = 0;
            
            // Atualizar controles
            scaleSlider.value = config.scale;
            scaleInput.value = config.scale;
            scaleValue.textContent = config.scale;
            
            offsetXSlider.value = config.offsetX;
            offsetXInput.value = config.offsetX;
            offsetXValue.textContent = config.offsetX;
            
            offsetYSlider.value = config.offsetY;
            offsetYInput.value = config.offsetY;
            offsetYValue.textContent = config.offsetY;
            
            positionSlider.value = config.position;
            positionDisplay.textContent = config.position + '%';
            
            // APLICAR A TRANSFORMA√á√ÉO IMEDIATAMENTE
            applyTransform();
            
            console.log('üì∫ Valores corretos aplicados automaticamente');
        }

        // Atualizar escala
        function updateScale(value) {
            config.scale = parseFloat(value);
            scaleSlider.value = config.scale;
            scaleInput.value = config.scale;
            scaleValue.textContent = config.scale.toFixed(2);
            applyTransform();
        }

        // Atualizar offset X
        function updateOffsetX(value) {
            config.offsetX = parseInt(value);
            offsetXSlider.value = config.offsetX;
            offsetXInput.value = config.offsetX;
            offsetXValue.textContent = config.offsetX;
            applyTransform();
        }

        // Atualizar offset Y
        function updateOffsetY(value) {
            config.offsetY = parseInt(value);
            offsetYSlider.value = config.offsetY;
            offsetYInput.value = config.offsetY;
            offsetYValue.textContent = config.offsetY;
            applyTransform();
        }

        // Atualizar posi√ß√£o
        function updatePosition(value) {
            config.position = parseFloat(value);
            positionSlider.value = config.position;
            positionDisplay.textContent = config.position + '%';
            applyTransform();
        }

        // Aplicar transforma√ß√£o
        function applyTransform() {
            // Calcular movimento horizontal baseado na posi√ß√£o
            // 100% do slider = posi√ß√£o final da imagem (translateX = -444px)
            const maxPosition = 100; // Posi√ß√£o m√°xima real (limite da imagem)
            
            // Calcular maxMovement baseado nos valores corretos:
            // offsetX inicial = 446px, offsetX final = -444px
            // Diferen√ßa = 446 - (-444) = 890px
            const maxMovement = 890; // Movimento m√°ximo em pixels (calculado)
            
            // Mapear 0-100% do slider para 0-100% real
            const realPosition = (config.position / 100) * maxPosition;
            const horizontalOffset = (realPosition / maxPosition) * maxMovement;
            
            const translateX = config.offsetX - horizontalOffset;
            const translateY = config.offsetY;
            
            const transform = `scale(${config.scale}) translate(${translateX}px, ${translateY}px)`;
            backgroundImage.style.transform = transform;
            
            // Aplicar a MESMA transforma√ß√£o √† √°rea de intera√ß√£o
            if (interactionArea) {
                interactionArea.style.transform = transform;
                console.log('üéØ √Årea de intera√ß√£o transformada:', transform);
            }
            
            console.log('üîÑ Posi√ß√£o real:', realPosition.toFixed(1) + '%', 'Transform:', transform);
        }

        // Fun√ß√£o de intera√ß√£o com a √°rea
        function interactWithArea() {
            console.log('üéÆ Intera√ß√£o com √°rea de teste');
            alert('üéØ √Årea de Intera√ß√£o! Esta √°rea se move com a imagem de fundo.');
        }

        // Calcular posi√ß√£o real em cent√≠metros
        function getPositionInCentimeters(position) {
            return (position / 100) * USABLE_TRACK_CM;
        }

        // Calcular posi√ß√£o real em pixels na tela
        function getPositionInPixels(position) {
            const centimeters = getPositionInCentimeters(position);
            // Assumindo que 1cm = 1px para simplificar (pode ser ajustado)
            return centimeters;
        }

        // Lidar com scroll do mouse nos campos de n√∫mero
        function handleScroll(event) {
            event.preventDefault();
            
            const input = event.target;
            const currentValue = parseFloat(input.value);
            const step = parseFloat(input.step) || 0.01;
            const min = parseFloat(input.min) || 0;
            const max = parseFloat(input.max) || 100;
            
            let newValue;
            if (event.deltaY < 0) {
                // Scroll para cima - aumentar
                newValue = Math.min(currentValue + step, max);
            } else {
                // Scroll para baixo - diminuir
                newValue = Math.max(currentValue - step, min);
            }
            
            input.value = newValue;
            
            // Atualizar o valor correspondente
            if (input.id === 'scaleInput') {
                updateScale(newValue);
            } else if (input.id === 'offsetXInput') {
                updateOffsetX(newValue);
            } else if (input.id === 'offsetYInput') {
                updateOffsetY(newValue);
            }
        }

        // Fun√ß√µes de controle
        function reset() {
            config.scale = 5.72;
            config.offsetX = 446;
            config.offsetY = 96;
            config.position = 0;
            
            updateScale(5.72);
            updateOffsetX(446);
            updateOffsetY(96);
            updatePosition(0);
            
            console.log('üîÑ Resetado para valores que funcionaram');
        }

        function center() {
            config.offsetX = 0;
            config.offsetY = 0;
            
            updateOffsetX(0);
            updateOffsetY(0);
            
            console.log('üéØ Centralizado');
        }

        function fitToTV() {
            // DESABILITADO - valores j√° aplicados automaticamente
            console.log('üì∫ Valores j√° est√£o corretos automaticamente!');
        }

        function zoomIn() {
            config.scale = Math.min(config.scale + 0.5, 10.0);
            updateScale(config.scale);
            console.log('üîç Zoom in:', config.scale);
        }

        function zoomOut() {
            config.scale = Math.max(config.scale - 0.5, 0.1);
            updateScale(config.scale);
            console.log('üîç Zoom out:', config.scale);
        }

        function saveCalibration() {
            localStorage.setItem('trilho_calibration', JSON.stringify(config));
            console.log('üíæ Calibra√ß√£o salva:', config);
            alert('Calibra√ß√£o salva com sucesso!');
        }

        function loadCalibration() {
            const saved = localStorage.getItem('trilho_calibration');
            if (saved) {
                config = JSON.parse(saved);
                updateScale(config.scale);
                updateOffsetX(config.offsetX);
                updateOffsetY(config.offsetY);
                updatePosition(config.position);
                console.log('üìÅ Calibra√ß√£o carregada:', config);
            }
        }

        function toggleMode() {
            const controls = document.querySelector('.controls');
            const isHidden = controls.style.display === 'none';
            
            if (isHidden) {
                controls.style.display = 'block';
                console.log('üîß Modo Calibra√ß√£o ativado');
            } else {
                controls.style.display = 'none';
                console.log('üéÆ Modo Uso ativado - apenas movimento');
            }
        }

        // Conectar ao cliente UDP real
        function connectUDP() {
            if (window.udpClient) {
                // Registrar callback para receber dados UDP reais
                window.udpClient.onPositionUpdate((position) => {
                    console.log('üì° UDP real recebido:', position.toFixed(3));
                    
                    // Mapear para slider (0 a 100%)
                    const sliderPosition = position * 100;
                    updatePosition(sliderPosition);
                });
                
                // Tentar conectar ao WebSocket real
                window.udpClient.startUDPListener();
                console.log('üì° Conectando ao UDP real...');
            } else {
                console.error('‚ùå Cliente UDP n√£o encontrado');
            }
        }

        // Alternar UDP
        function toggleUDP() {
            const udpButton = document.getElementById('udpButton');
            
            if (udpEnabled) {
                // Desabilitar UDP
                udpEnabled = false;
                udpButton.textContent = 'üì° UDP OFF';
                udpButton.style.background = '#666';
                console.log('üì° UDP desabilitado');
            } else {
                // Habilitar UDP real
                connectUDP();
                udpEnabled = true;
                udpButton.textContent = 'üì° UDP ON';
                udpButton.style.background = '#4CAF50';
                console.log('üì° UDP habilitado - aguardando dados reais');
            }
        }

        // Inicializar
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
