<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trilho Digital</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #000;
            height: 100vh;
            overflow: hidden;
        }
        
        .viewport {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: #000;
            overflow: hidden;
            cursor: grab;
            user-select: none;
        }
        
        .viewport:active {
            cursor: grabbing;
        }
        
        .background-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            transform-origin: center center;
        }
        
        .slider {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 40px;
            background: rgba(0,0,0,0.7);
            border-radius: 20px;
            padding: 5px;
            z-index: 100;
        }
        
        .slider input {
            width: 100%;
            height: 100%;
            -webkit-appearance: none;
            background: transparent;
            outline: none;
        }
        
        .slider input::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 30px;
            height: 30px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .position-display {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 18px;
            z-index: 100;
        }
        
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 25px;
            border-radius: 10px;
            z-index: 100;
            min-width: 300px;
            font-size: 16px;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 10px;
            font-size: 16px;
            font-weight: bold;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            height: 75px;
            margin-bottom: 5px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 10px;
            outline: none;
        }
        
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 30px;
            height: 30px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .control-group input[type="range"]::-moz-range-thumb {
            width: 30px;
            height: 30px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .control-group input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 2px solid #555;
            background: #222;
            color: white;
            border-radius: 5px;
            font-size: 16px;
            margin-bottom: 10px;
        }
        
        .control-group input[type="number"]:focus {
            border-color: #4CAF50;
            outline: none;
        }
        
        .btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
            font-weight: bold;
        }
        
        .control-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #555;
            background: #222;
            color: white;
            border-radius: 5px;
            font-size: 16px;
            margin-bottom: 10px;
        }
        
        .control-group select:focus {
            border-color: #4CAF50;
            outline: none;
        }
    </style>
</head>
<body>
    <div class="viewport">
        <div class="background-image" id="backgroundImage"></div>
    </div>
    
    <div class="controls">
        <div class="control-group">
            <label>Escala: <span id="scaleValue">5.72</span></label>
            <input type="range" id="scaleSlider" min="0.1" max="10.0" step="0.01" value="5.72">
            <input type="number" id="scaleInput" min="0.1" max="10.0" step="0.01" value="5.72">
        </div>
        
        <div class="control-group">
            <label>X: <span id="offsetXValue">446</span></label>
            <input type="range" id="offsetXSlider" min="-5000" max="5000" step="1" value="446">
            <input type="number" id="offsetXInput" min="-5000" max="5000" step="1" value="446">
        </div>
        
        <div class="control-group">
            <label>Y: <span id="offsetYValue">96</span></label>
            <input type="range" id="offsetYSlider" min="-5000" max="5000" step="1" value="96">
            <input type="number" id="offsetYInput" min="-5000" max="5000" step="1" value="96">
        </div>
        
        <button class="btn" onclick="reset()">Reset</button>
        <button class="btn" onclick="center()">Centralizar</button>
        <button class="btn" onclick="fitToTV()">Encaixar na TV</button>
        <button class="btn" onclick="zoomIn()">+</button>
        <button class="btn" onclick="zoomOut()">-</button>
        <button class="btn" onclick="saveCalibration()">üíæ Salvar</button>
        <button class="btn" onclick="toggleMode()">üéÆ Modo Uso</button>
        <button class="btn" onclick="toggleUDP()" id="udpButton">üì° UDP OFF</button>
        
        <div class="control-group">
            <label>Interpola√ß√£o: <span id="interpolationValue">0.3s</span></label>
            <input type="range" id="interpolationSlider" min="0.1" max="2.0" step="0.1" value="0.3">
        </div>
        
        <div class="control-group">
            <label>Easing: <span id="easingValue">power2.out</span></label>
            <select id="easingSelect" onchange="updateEasing()">
                <option value="power2.out">Suave (power2.out)</option>
                <option value="power3.out">Mais suave (power3.out)</option>
                <option value="power4.out">Muito suave (power4.out)</option>
                <option value="back.out">El√°stico (back.out)</option>
                <option value="bounce.out">Saltitante (bounce.out)</option>
                <option value="linear">Linear</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Sensibilidade Arrastar: <span id="dragSensitivityValue">0.05</span></label>
            <input type="range" id="dragSensitivitySlider" min="0.01" max="0.5" step="0.01" value="0.05">
        </div>
        
        <div class="control-group">
            <label>Sensibilidade Zoom: <span id="zoomSensitivityValue">0.02</span></label>
            <input type="range" id="zoomSensitivitySlider" min="0.005" max="0.1" step="0.005" value="0.02">
        </div>
    </div>
    
    <div class="slider">
        <input type="range" id="positionSlider" min="0" max="100" step="0.1" value="0">
    </div>
    
    <div class="position-display" id="positionDisplay">0%</div>
    
    <!-- Indicador de modo de controle -->
    <div id="controlModeIndicator" class="position-display" style="top: 60px; background: rgba(0,0,0,0.8); font-size: 14px;">
        üñ±Ô∏è Arrastar habilitado
    </div>
    
    <!-- Indicador de atalhos de teclado -->
    <div id="keyboardShortcuts" class="position-display" style="top: 100px; background: rgba(0,0,0,0.8); font-size: 12px; max-width: 300px;">
        ‚å®Ô∏è Setas: mover ‚Ä¢ Shift+Setas: r√°pido ‚Ä¢ +/-: zoom ‚Ä¢ R: reset ‚Ä¢ C: modo ‚Ä¢ S: salvar ‚Ä¢ P: UDP (uso) ‚Ä¢ ESC: sair sem salvar
    </div>

    <!-- GSAP para interpola√ß√£o suave -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    
    <!-- Cliente UDP -->
    <script src="udp-client.js"></script>
    
    <script>
        // Estado com valores que funcionaram - carregar j√° no tamanho correto
        let config = {
            scale: 5.72,
            offsetX: 446,
            offsetY: 96,
            position: 0
        };

        // Controle UDP
        let udpEnabled = false;
        let udpInterval = null;
        
        // Estados do sistema
        let currentMode = 'calibration'; // 'calibration' ou 'usage'
        let hasChanges = false; // Para controlar se h√° altera√ß√µes n√£o salvas

        // Interpola√ß√£o GSAP para movimento suave
        let gsapTween = null;
        let targetPosition = 0; // Posi√ß√£o alvo recebida via UDP
        let currentPosition = 0; // Posi√ß√£o atual interpolada
        let isInterpolating = false;

        // Controle de mouse/touch
        let isDragging = false;
        let lastMousePos = { x: 0, y: 0 };
        let lastTouch = null;
        let pinch = null;
        
        // Sensibilidades ajust√°veis
        let dragSensitivity = 0.05; // Muito mais suave
        let zoomSensitivity = 0.02;
        
        // Configura√ß√µes da interpola√ß√£o
        const INTERPOLATION_CONFIG = {
            duration: 0.3, // Dura√ß√£o da interpola√ß√£o em segundos
            ease: "power2.out", // Easing para movimento natural
            onUpdate: () => {
                // Atualizar posi√ß√£o durante a interpola√ß√£o
                updatePositionFromInterpolation(currentPosition);
            },
            onComplete: () => {
                isInterpolating = false;
                console.log('üé¨ Interpola√ß√£o conclu√≠da');
            }
        };

        // Elementos
        const viewport = document.querySelector('.viewport');
        const backgroundImage = document.getElementById('backgroundImage');
        const positionSlider = document.getElementById('positionSlider');
        const positionDisplay = document.getElementById('positionDisplay');
        
        const scaleSlider = document.getElementById('scaleSlider');
        const scaleInput = document.getElementById('scaleInput');
        const scaleValue = document.getElementById('scaleValue');
        
        const offsetXSlider = document.getElementById('offsetXSlider');
        const offsetXInput = document.getElementById('offsetXInput');
        const offsetXValue = document.getElementById('offsetXValue');
        
        const offsetYSlider = document.getElementById('offsetYSlider');
        const offsetYInput = document.getElementById('offsetYInput');
        const offsetYValue = document.getElementById('offsetYValue');
        
        const interpolationSlider = document.getElementById('interpolationSlider');
        const interpolationValue = document.getElementById('interpolationValue');
        const easingSelect = document.getElementById('easingSelect');
        const easingValue = document.getElementById('easingValue');
        
        const dragSensitivitySlider = document.getElementById('dragSensitivitySlider');
        const dragSensitivityValue = document.getElementById('dragSensitivityValue');
        const zoomSensitivitySlider = document.getElementById('zoomSensitivitySlider');
        const zoomSensitivityValue = document.getElementById('zoomSensitivityValue');

        // Inicializar
        function init() {
            console.log('üöÄ Iniciando...');
            
            // Carregar imagem
            backgroundImage.style.backgroundImage = 'url(editor/bg300x200-comtv.jpg)';
            
            // Event listeners
            positionSlider.addEventListener('input', () => updatePosition(positionSlider.value));
            
            scaleSlider.addEventListener('input', () => updateScale(scaleSlider.value));
            scaleInput.addEventListener('input', () => updateScale(scaleInput.value));
            scaleInput.addEventListener('wheel', handleScroll);
            
            offsetXSlider.addEventListener('input', () => updateOffsetX(offsetXSlider.value));
            offsetXInput.addEventListener('input', () => updateOffsetX(offsetXInput.value));
            offsetXInput.addEventListener('wheel', handleScroll);
            
            offsetYSlider.addEventListener('input', () => updateOffsetY(offsetYSlider.value));
            offsetYInput.addEventListener('input', () => updateOffsetY(offsetYInput.value));
            offsetYInput.addEventListener('wheel', handleScroll);
            
            // Controles de interpola√ß√£o
            interpolationSlider.addEventListener('input', () => updateInterpolationDuration(interpolationSlider.value));
            
            // Controles de sensibilidade
            dragSensitivitySlider.addEventListener('input', () => updateDragSensitivity(dragSensitivitySlider.value));
            zoomSensitivitySlider.addEventListener('input', () => updateZoomSensitivity(zoomSensitivitySlider.value));
            
            // Event listeners para mouse/touch
            viewport.addEventListener('mousedown', handleMouseDown);
            viewport.addEventListener('mousemove', handleMouseMove);
            viewport.addEventListener('mouseup', handleMouseUp);
            viewport.addEventListener('mouseleave', handleMouseUp);
            viewport.addEventListener('wheel', handleWheel, { passive: false });
            
            // Event listeners para touch
            viewport.addEventListener('touchstart', handleTouchStart, { passive: false });
            viewport.addEventListener('touchmove', handleTouchMove, { passive: false });
            viewport.addEventListener('touchend', handleTouchEnd);
            
            // Event listeners para teclado
            window.addEventListener('keydown', handleKeyDown);
            
            // Aplicar valores corretos automaticamente (sem carregar calibra√ß√£o antiga)
            applyCorrectValues();
            
            // Inicializar controles de interpola√ß√£o
            interpolationValue.textContent = INTERPOLATION_CONFIG.duration + 's';
            easingValue.textContent = INTERPOLATION_CONFIG.ease;
            
            // Inicializar controles de sensibilidade
            dragSensitivityValue.textContent = dragSensitivity.toFixed(1);
            zoomSensitivityValue.textContent = zoomSensitivity.toFixed(3);
            
            console.log('‚úÖ Pronto!');
        }
        
        // Aplicar valores corretos automaticamente
        function applyCorrectValues() {
            config.scale = 5.72;
            config.offsetX = 446;
            config.offsetY = 96;
            config.position = 0;
            
            // Atualizar controles
            scaleSlider.value = config.scale;
            scaleInput.value = config.scale;
            scaleValue.textContent = config.scale;
            
            offsetXSlider.value = config.offsetX;
            offsetXInput.value = config.offsetX;
            offsetXValue.textContent = config.offsetX;
            
            offsetYSlider.value = config.offsetY;
            offsetYInput.value = config.offsetY;
            offsetYValue.textContent = config.offsetY;
            
            positionSlider.value = config.position;
            positionDisplay.textContent = config.position + '%';
            
            // APLICAR A TRANSFORMA√á√ÉO IMEDIATAMENTE
            applyTransform();
            
            console.log('üì∫ Valores corretos aplicados automaticamente');
        }

        // Atualizar escala
        function updateScale(value) {
            config.scale = parseFloat(value);
            scaleSlider.value = config.scale;
            scaleInput.value = config.scale;
            scaleValue.textContent = config.scale.toFixed(2);
            applyTransform();
            markAsChanged();
        }

        // Atualizar offset X
        function updateOffsetX(value) {
            config.offsetX = parseInt(value);
            offsetXSlider.value = config.offsetX;
            offsetXInput.value = config.offsetX;
            offsetXValue.textContent = config.offsetX;
            applyTransform();
            markAsChanged();
        }

        // Atualizar offset Y
        function updateOffsetY(value) {
            config.offsetY = parseInt(value);
            offsetYSlider.value = config.offsetY;
            offsetYInput.value = config.offsetY;
            offsetYValue.textContent = config.offsetY;
            applyTransform();
            markAsChanged();
        }

        // Atualizar posi√ß√£o (para controle manual)
        function updatePosition(value) {
            config.position = parseFloat(value);
            positionSlider.value = config.position;
            positionDisplay.textContent = config.position + '%';
            applyTransform();
        }

        // Atualizar posi√ß√£o via interpola√ß√£o GSAP (para UDP)
        function updatePositionFromInterpolation(value) {
            config.position = parseFloat(value);
            positionSlider.value = config.position;
            positionDisplay.textContent = config.position.toFixed(1) + '%';
            applyTransform();
        }

        // Interpolar para nova posi√ß√£o (usado pelo UDP)
        function interpolateToPosition(targetValue) {
            targetPosition = parseFloat(targetValue);
            
            // Se j√° est√° interpolando, interromper e come√ßar nova interpola√ß√£o
            if (isInterpolating && gsapTween) {
                gsapTween.kill();
            }
            
            // Iniciar nova interpola√ß√£o
            isInterpolating = true;
            gsapTween = gsap.to({ value: currentPosition }, {
                value: targetPosition,
                duration: INTERPOLATION_CONFIG.duration,
                ease: INTERPOLATION_CONFIG.ease,
                onUpdate: function() {
                    currentPosition = this.targets()[0].value;
                    updatePositionFromInterpolation(currentPosition);
                },
                onComplete: () => {
                    isInterpolating = false;
                    currentPosition = targetPosition;
                    console.log('üé¨ Interpola√ß√£o conclu√≠da - Posi√ß√£o final:', targetPosition.toFixed(1) + '%');
                }
            });
            
            console.log('üé¨ Iniciando interpola√ß√£o:', currentPosition.toFixed(1) + '% ‚Üí ' + targetPosition.toFixed(1) + '%');
        }

        // Atualizar dura√ß√£o da interpola√ß√£o
        function updateInterpolationDuration(value) {
            INTERPOLATION_CONFIG.duration = parseFloat(value);
            interpolationValue.textContent = value + 's';
            console.log('‚öôÔ∏è Dura√ß√£o da interpola√ß√£o:', value + 's');
        }

        // Atualizar tipo de easing
        function updateEasing() {
            INTERPOLATION_CONFIG.ease = easingSelect.value;
            easingValue.textContent = easingSelect.value;
            console.log('‚öôÔ∏è Easing atualizado:', easingSelect.value);
        }

        // Atualizar sensibilidade do arrastar
        function updateDragSensitivity(value) {
            dragSensitivity = parseFloat(value);
            dragSensitivityValue.textContent = dragSensitivity.toFixed(1);
            console.log('‚öôÔ∏è Sensibilidade do arrastar:', dragSensitivity);
        }

        // Atualizar sensibilidade do zoom
        function updateZoomSensitivity(value) {
            zoomSensitivity = parseFloat(value);
            zoomSensitivityValue.textContent = zoomSensitivity.toFixed(3);
            console.log('‚öôÔ∏è Sensibilidade do zoom:', zoomSensitivity);
        }

        // Marcar como alterado
        function markAsChanged() {
            hasChanges = true;
            updateSaveIndicator();
        }

        // Limpar altera√ß√µes
        function clearChanges() {
            hasChanges = false;
            updateSaveIndicator();
        }

        // Atualizar indicador de salvar
        function updateSaveIndicator() {
            const controlModeIndicator = document.getElementById('controlModeIndicator');
            if (hasChanges && currentMode === 'calibration') {
                controlModeIndicator.textContent = 'üîß Modo Calibra√ß√£o ‚Ä¢ üíæ SALVAR (S)';
                controlModeIndicator.style.background = 'rgba(255,100,0,0.8)';
            } else if (currentMode === 'calibration') {
                controlModeIndicator.textContent = 'üîß Modo Calibra√ß√£o';
                controlModeIndicator.style.background = 'rgba(200,100,0,0.8)';
            } else if (currentMode === 'usage' && udpEnabled) {
                controlModeIndicator.textContent = 'üéÆ Modo Uso ‚Ä¢ üì° UDP ON';
                controlModeIndicator.style.background = 'rgba(0,100,200,0.8)';
            } else {
                controlModeIndicator.textContent = 'üéÆ Modo Uso';
                controlModeIndicator.style.background = 'rgba(0,150,0,0.8)';
            }
        }

        // Salvar configura√ß√£o
        function saveConfiguration() {
            localStorage.setItem('trilho_calibration', JSON.stringify(config));
            clearChanges();
            console.log('üíæ Configura√ß√£o salva:', config);
            alert('Configura√ß√£o salva com sucesso!');
        }

        // Fun√ß√µes de controle de mouse/touch
        function getMousePos(e) {
            const rect = viewport.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        function getTouchPos(touch) {
            const rect = viewport.getBoundingClientRect();
            return {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
        }

        function getDistance(p1, p2) {
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            return Math.hypot(dx, dy);
        }

        // Controle de zoom com scroll
        function handleWheel(e) {
            e.preventDefault();
            
            const delta = e.deltaY;
            const newScale = config.scale + (delta > 0 ? -zoomSensitivity : zoomSensitivity);
            
            // Limitar escala
            const clampedScale = Math.max(0.1, Math.min(10.0, newScale));
            
            if (clampedScale !== config.scale) {
                updateScale(clampedScale);
                console.log('üîç Zoom:', config.scale.toFixed(2));
            }
        }

        // Controle de arrastar com mouse
        function handleMouseDown(e) {
            if (udpEnabled) return; // S√≥ permite arrastar se UDP estiver desabilitado
            
            isDragging = true;
            lastMousePos = getMousePos(e);
            viewport.style.cursor = 'grabbing';
            e.preventDefault();
        }

        function handleMouseMove(e) {
            if (!isDragging || udpEnabled) return;
            
            const currentPos = getMousePos(e);
            const deltaX = currentPos.x - lastMousePos.x;
            const deltaY = currentPos.y - lastMousePos.y;
            
            // Sensibilidade ajust√°vel do arrastar
            const newOffsetX = config.offsetX + (deltaX * dragSensitivity);
            const newOffsetY = config.offsetY + (deltaY * dragSensitivity);
            
            updateOffsetX(newOffsetX);
            updateOffsetY(newOffsetY);
            
            lastMousePos = currentPos;
        }

        function handleMouseUp(e) {
            isDragging = false;
            viewport.style.cursor = 'grab';
        }

        // Controle de touch
        function handleTouchStart(e) {
            if (udpEnabled) return;
            
            if (e.touches.length === 1) {
                lastTouch = getTouchPos(e.touches[0]);
            } else if (e.touches.length === 2) {
                const p1 = getTouchPos(e.touches[0]);
                const p2 = getTouchPos(e.touches[1]);
                const distance = getDistance(p1, p2);
                const centerX = (p1.x + p2.x) / 2;
                const centerY = (p1.y + p2.y) / 2;
                
                pinch = {
                    distance: distance,
                    scale: config.scale,
                    centerX: centerX,
                    centerY: centerY
                };
            }
        }

        function handleTouchMove(e) {
            if (udpEnabled) return;
            
            e.preventDefault();
            
            if (e.touches.length === 1 && lastTouch) {
                // Arrastar com um dedo
                const currentTouch = getTouchPos(e.touches[0]);
                const deltaX = currentTouch.x - lastTouch.x;
                const deltaY = currentTouch.y - lastTouch.y;
                
                const newOffsetX = config.offsetX + (deltaX * dragSensitivity);
                const newOffsetY = config.offsetY + (deltaY * dragSensitivity);
                
                updateOffsetX(newOffsetX);
                updateOffsetY(newOffsetY);
                
                lastTouch = currentTouch;
            } else if (e.touches.length === 2 && pinch) {
                // Pinch para zoom
                const p1 = getTouchPos(e.touches[0]);
                const p2 = getTouchPos(e.touches[1]);
                const currentDistance = getDistance(p1, p2);
                
                const scaleFactor = currentDistance / pinch.distance;
                const newScale = pinch.scale * scaleFactor;
                const clampedScale = Math.max(0.1, Math.min(10.0, newScale));
                
                if (clampedScale !== config.scale) {
                    // Ajustar offset para manter o centro do zoom
                    const scaleDiff = clampedScale - config.scale;
                    const newOffsetX = config.offsetX + (pinch.centerX * scaleDiff);
                    const newOffsetY = config.offsetY + (pinch.centerY * scaleDiff);
                    
                    updateScale(clampedScale);
                    updateOffsetX(newOffsetX);
                    updateOffsetY(newOffsetY);
                }
            }
        }

        function handleTouchEnd(e) {
            if (e.touches.length === 0) {
                lastTouch = null;
                pinch = null;
            } else if (e.touches.length === 1) {
                pinch = null;
                lastTouch = getTouchPos(e.touches[0]);
            }
        }

        // Controle de teclado
        function handleKeyDown(e) {
            const step = e.shiftKey ? 10 : 1; // SHIFT = movimento mais r√°pido
            
            switch(e.key) {
                case 'ArrowLeft':
                    e.preventDefault();
                    if (currentMode === 'calibration') {
                        updateOffsetX(config.offsetX - step);
                        console.log('‚¨ÖÔ∏è Offset X:', config.offsetX);
                    }
                    break;
                    
                case 'ArrowRight':
                    e.preventDefault();
                    if (currentMode === 'calibration') {
                        updateOffsetX(config.offsetX + step);
                        console.log('‚û°Ô∏è Offset X:', config.offsetX);
                    }
                    break;
                    
                case 'ArrowUp':
                    e.preventDefault();
                    if (currentMode === 'calibration') {
                        updateOffsetY(config.offsetY - step);
                        console.log('‚¨ÜÔ∏è Offset Y:', config.offsetY);
                    }
                    break;
                    
                case 'ArrowDown':
                    e.preventDefault();
                    if (currentMode === 'calibration') {
                        updateOffsetY(config.offsetY + step);
                        console.log('‚¨áÔ∏è Offset Y:', config.offsetY);
                    }
                    break;
                    
                case '=':
                case '+':
                    e.preventDefault();
                    if (currentMode === 'calibration') {
                        updateScale(Math.min(config.scale + 0.1, 10.0));
                        console.log('üîç Zoom in:', config.scale.toFixed(2));
                    }
                    break;
                    
                case '-':
                    e.preventDefault();
                    if (currentMode === 'calibration') {
                        updateScale(Math.max(config.scale - 0.1, 0.1));
                        console.log('üîç Zoom out:', config.scale.toFixed(2));
                    }
                    break;
                    
                case 'r':
                case 'R':
                    e.preventDefault();
                    if (currentMode === 'calibration') {
                        reset();
                        clearChanges();
                        console.log('üîÑ Reset aplicado');
                    }
                    break;
                    
                case 'c':
                case 'C':
                    e.preventDefault();
                    toggleMode();
                    break;
                    
                case 's':
                case 'S':
                    e.preventDefault();
                    if (currentMode === 'calibration' && hasChanges) {
                        saveConfiguration();
                    }
                    break;
                    
                case 'p':
                case 'P':
                    e.preventDefault();
                    if (currentMode === 'usage') {
                        toggleUDP(); // UDP s√≥ funciona em modo USO
                    }
                    break;
                    
                case 'Escape':
                    e.preventDefault();
                    if (currentMode === 'calibration') {
                        // ESC: fazer exatamente a mesma coisa que C (sair sem salvar)
                        console.log('‚ö†Ô∏è ESC pressionado - saindo do modo calibra√ß√£o sem salvar');
                        console.log('üîç Estado atual - currentMode:', currentMode, 'hasChanges:', hasChanges);
                        toggleMode(); // Sai do modo calibra√ß√£o (mesma l√≥gica do C)
                        console.log('‚úÖ toggleMode() executado via ESC, currentMode agora:', currentMode);
                    } else {
                        console.log('‚ö†Ô∏è ESC pressionado mas n√£o est√° em modo calibra√ß√£o. currentMode:', currentMode);
                    }
                    break;
            }
        }

        // Aplicar transforma√ß√£o
        function applyTransform() {
            // Calcular movimento horizontal baseado na posi√ß√£o
            // 100% do slider = posi√ß√£o final da imagem (translateX = -444px)
            const maxPosition = 100; // Posi√ß√£o m√°xima real (limite da imagem)
            
            // Calcular maxMovement baseado nos valores corretos:
            // offsetX inicial = 446px, offsetX final = -444px
            // Diferen√ßa = 446 - (-444) = 890px
            const maxMovement = 890; // Movimento m√°ximo em pixels (calculado)
            
            // Verificar se config.position existe, sen√£o usar 0
            const position = config.position !== undefined ? config.position : 0;
            
            // Mapear 0-100% do slider para 0-100% real
            const realPosition = (position / 100) * maxPosition;
            const horizontalOffset = (realPosition / maxPosition) * maxMovement;
            
            const translateX = (config.offsetX || 0) - horizontalOffset;
            const translateY = config.offsetY || 0;
            
            const transform = `scale(${config.scale || 1}) translate(${translateX}px, ${translateY}px)`;
            backgroundImage.style.transform = transform;
            
            console.log('üîÑ applyTransform() - Posi√ß√£o:', position.toFixed(1) + '%', 'Real:', realPosition.toFixed(1) + '%', 'Offset:', horizontalOffset.toFixed(1) + 'px', 'TranslateX:', translateX.toFixed(1) + 'px');
            console.log('üîÑ Transform completo:', transform);
        }

        // Lidar com scroll do mouse nos campos de n√∫mero
        function handleScroll(event) {
            event.preventDefault();
            
            const input = event.target;
            const currentValue = parseFloat(input.value);
            const step = parseFloat(input.step) || 0.01;
            const min = parseFloat(input.min) || 0;
            const max = parseFloat(input.max) || 100;
            
            let newValue;
            if (event.deltaY < 0) {
                // Scroll para cima - aumentar
                newValue = Math.min(currentValue + step, max);
            } else {
                // Scroll para baixo - diminuir
                newValue = Math.max(currentValue - step, min);
            }
            
            input.value = newValue;
            
            // Atualizar o valor correspondente
            if (input.id === 'scaleInput') {
                updateScale(newValue);
            } else if (input.id === 'offsetXInput') {
                updateOffsetX(newValue);
            } else if (input.id === 'offsetYInput') {
                updateOffsetY(newValue);
            }
        }

        // Fun√ß√µes de controle
        function reset() {
            config.scale = 5.72;
            config.offsetX = 446;
            config.offsetY = 96;
            config.position = 0;
            
            updateScale(5.72);
            updateOffsetX(446);
            updateOffsetY(96);
            updatePosition(0);
            
            console.log('üîÑ Resetado para valores que funcionaram');
        }

        function center() {
            config.offsetX = 0;
            config.offsetY = 0;
            
            updateOffsetX(0);
            updateOffsetY(0);
            
            console.log('üéØ Centralizado');
        }

        function fitToTV() {
            // DESABILITADO - valores j√° aplicados automaticamente
            console.log('üì∫ Valores j√° est√£o corretos automaticamente!');
        }

        function zoomIn() {
            config.scale = Math.min(config.scale + 0.5, 10.0);
            updateScale(config.scale);
            console.log('üîç Zoom in:', config.scale);
        }

        function zoomOut() {
            config.scale = Math.max(config.scale - 0.5, 0.1);
            updateScale(config.scale);
            console.log('üîç Zoom out:', config.scale);
        }

        function saveCalibration() {
            localStorage.setItem('trilho_calibration', JSON.stringify(config));
            console.log('üíæ Calibra√ß√£o salva:', config);
            alert('Calibra√ß√£o salva com sucesso!');
        }

        function loadCalibration() {
            const saved = localStorage.getItem('trilho_calibration');
            if (saved) {
                config = JSON.parse(saved);
                updateScale(config.scale);
                updateOffsetX(config.offsetX);
                updateOffsetY(config.offsetY);
                updatePosition(config.position);
                console.log('üìÅ Calibra√ß√£o carregada:', config);
            }
        }

        function toggleMode() {
            const controls = document.querySelector('.controls');
            const controlModeIndicator = document.getElementById('controlModeIndicator');
            const keyboardShortcuts = document.getElementById('keyboardShortcuts');
            
            console.log('üîÑ toggleMode() chamado - currentMode atual:', currentMode);
            console.log('üîç Elementos encontrados - controls:', controls, 'keyboardShortcuts:', keyboardShortcuts);
            
            if (currentMode === 'calibration') {
                // Mudar para modo USO - ativar UDP automaticamente
                currentMode = 'usage';
                controls.style.display = 'none';
                keyboardShortcuts.style.display = 'block';
                
                // Se h√° altera√ß√µes n√£o salvas, descartar e restaurar valores salvos
                if (hasChanges) {
                    console.log('‚ö†Ô∏è Altera√ß√µes n√£o salvas descartadas ao sair do modo calibra√ß√£o');
                    loadCalibration(); // Restaura os valores salvos
                    clearChanges(); // Limpa o flag de altera√ß√µes
                }
                
                // Ativar UDP automaticamente no modo USO
                udpEnabled = true;
                connectUDP();
                const udpButton = document.getElementById('udpButton');
                udpButton.textContent = 'üì° UDP ON';
                udpButton.style.background = '#4CAF50';
                console.log('üì° UDP ativado automaticamente ao entrar no modo USO');
                
                updateSaveIndicator();
                console.log('üéÆ Modo Uso ativado');
            } else {
                // Mudar para modo CALIBRA√á√ÉO - desabilitar UDP automaticamente
                currentMode = 'calibration';
                controls.style.display = 'block';
                keyboardShortcuts.style.display = 'block';
                
                // Desabilitar UDP se estiver ativo
                if (udpEnabled) {
                    udpEnabled = false;
                    disconnectUDP();
                    const udpButton = document.getElementById('udpButton');
                    udpButton.textContent = 'üì° UDP OFF';
                    udpButton.style.background = '#666';
                    console.log('üì° UDP desabilitado automaticamente ao entrar no modo CALIBRA√á√ÉO');
                }
                
                updateSaveIndicator();
                console.log('üîß Modo Calibra√ß√£o ativado');
            }
        }

        // Callback para receber dados UDP
        let udpCallback = null;

        // Conectar ao cliente UDP real
        function connectUDP() {
            if (window.udpClient) {
                // Criar callback para receber dados UDP reais
                udpCallback = (position) => {
                    if (udpEnabled) { // S√≥ processa se UDP estiver habilitado
                        console.log('üì° UDP real recebido:', position.toFixed(3));
                        
                        // Verificar se a posi√ß√£o √© v√°lida
                        if (position !== null && position !== undefined && !isNaN(position)) {
                            // Mapear para slider (0 a 100%)
                            const sliderPosition = position * 100;
                            
                            console.log('üìä UDP - Posi√ß√£o original:', position, '‚Üí Slider:', sliderPosition.toFixed(1) + '%');
                            
                            // Usar interpola√ß√£o GSAP para movimento suave
                            interpolateToPosition(sliderPosition);
                        } else {
                            console.log('‚ö†Ô∏è Posi√ß√£o UDP inv√°lida, mantendo posi√ß√£o atual');
                        }
                    }
                };
                
                // Registrar callback
                window.udpClient.onPositionUpdate(udpCallback);
                
                // Tentar conectar ao WebSocket real
                window.udpClient.startUDPListener();
                console.log('üì° Conectando ao UDP real...');
            } else {
                console.error('‚ùå Cliente UDP n√£o encontrado');
            }
        }

        // Desconectar UDP
        function disconnectUDP() {
            if (window.udpClient && udpCallback) {
                // Remover callback
                window.udpClient.removeCallback(udpCallback);
                udpCallback = null;
                
                // Fechar WebSocket se existir
                if (window.udpClient.ws) {
                    window.udpClient.ws.close();
                }
                
                console.log('üì° UDP desconectado');
            }
        }

        // Alternar UDP
        function toggleUDP() {
            const udpButton = document.getElementById('udpButton');
            
            if (udpEnabled) {
                // Desabilitar UDP
                udpEnabled = false;
                disconnectUDP(); // Desconectar completamente
                udpButton.textContent = 'üì° UDP OFF';
                udpButton.style.background = '#666';
                console.log('üì° UDP desabilitado - dados n√£o ser√£o mais processados');
            } else {
                // Habilitar UDP real
                udpEnabled = true;
                connectUDP();
                udpButton.textContent = 'üì° UDP ON';
                udpButton.style.background = '#4CAF50';
                console.log('üì° UDP habilitado - aguardando dados reais');
            }
            
            // Atualizar indicador de modo
            updateSaveIndicator();
        }

        // Inicializar
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
